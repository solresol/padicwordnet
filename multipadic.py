#!/usr/bin/env python3

import argparse
import json
import numpy as np
import tqdm

parser = argparse.ArgumentParser()
parser.add_argument("--prime", type=int, default=409,
                    help="What prime was used with create_zorgette_catalogue.py")
parser.add_argument("--input-file", default="zorgette-catalog.json",
                    help="File generated by create_zorgette_catalogue.py. Should be a list of 3-element lists")
args = parser.parse_args()

data = json.load(open(args.input_file))

# Something funny about this... there's only one division. That
# doesn't seem right. Unless A is really big?
def cross_product(v1, v2):
    return (
        v1[1] * v2[2] - v1[2] * v2[1],
        v1[2] * v2[0] - v1[0] * v2[2],
        v1[0] * v2[1] - v1[1] * v2[0]
    )

def dot_product(v1, v2):
    return sum(x * y for x, y in zip(v1, v2))

def find_plane_equation(p1, p2, p3):
    v1 = [p2[i] - p1[i] for i in range(3)]
    v2 = [p3[i] - p1[i] for i in range(3)]
    normal = cross_product(v1, v2)
    A, B, C = normal
    D = -dot_product(normal, p1)
    return A, B, C, D

def solve_for_x(A, B, C, D, y, z):
    if A == 0:
        raise ValueError("A cannot be zero for this equation.")
    return (-B*y - C*z - D) // A  # Use integer division for integers and fractions

def padic_measure(prime, q):
    if q == 0:
        return 0.0
    if q % prime != 0:
        return 1.0
    return 1.0 + padic_measure(prime, q // prime)

def padic_distance(prime, r, s):
    q = r - s
    print(f"{r} - {s} = {q}")
    answer = prime ** (- padic_measure(prime, q))
    print(f"|{q}|_prime = {answer}")
    return answer
    
best_triple = None
score = None

for i, p1 in enumerate(data):
    for j, p2 in enumerate(data):
        if j <= i:
            continue
        for k, p3 in enumerate(data):
            if k <= i or k <= j:
                continue
            A, B, C, D = find_plane_equation(p1, p2, p3)
            # Now, we go through each point in our data set and
            # see what the residual is.
            sum_of_residuals = 0.0
            for p4 in data:
                p4_hat = solve_for_x(A, B, C, D, p4[1], p4[2])
                residual = padic_distance(args.prime, p4[0], p4_hat)
                #print(p1, p2, p3, p4, A, B, C, D, p4_hat, residual)
                sum_of_residuals += residual
            if score is None or sum_of_residuals < score:
                score = sum_of_residuals
                best_triple = (p1,p2,p3)

print(best_triple)
winning_equation =  find_plane_equation(best_triple[0], best_triple[1], best_triple[2])
print(winning_equation)

intercept = solve_for_x(winning_equation[0],
                    winning_equation[1],
                    winning_equation[2],
                    winning_equation[3],
                    0,
                    0)
print(intercept)

coef1 = solve_for_x(winning_equation[0],
                    winning_equation[1],
                    winning_equation[2],
                    winning_equation[3],
                    1,
                    0) - intercept
print(coef1)

coef2 = solve_for_x(winning_equation[0],
            winning_equation[1],
            winning_equation[2],
            winning_equation[3],
            0,
                    1) - intercept
print(coef2)
