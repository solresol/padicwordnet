#!/usr/bin/env python3

import argparse
import json
import fractions

parser = argparse.ArgumentParser()
parser.add_argument("--prime", type=int, default=409,
                    help="What prime was used with create_zorgette_catalogue.py")
parser.add_argument("--input-file", default="zorgette-catalog.json",
                    help="File generated by create_zorgette_catalogue.py. Should be a list of 3-element lists")
args = parser.parse_args()

data = json.load(open(args.input_file))

# Something funny about this... there's only one division. That
# doesn't seem right. Unless A is really big?
def cross_product(v1, v2):
    return (
        v1[1] * v2[2] - v1[2] * v2[1],
        v1[2] * v2[0] - v1[0] * v2[2],
        v1[0] * v2[1] - v1[1] * v2[0]
    )

def dot_product(v1, v2):
    return sum(x * y for x, y in zip(v1, v2))

def fraction_format(numerator, denominator, variable="", include_plus=False):
    f = fractions.Fraction(numerator, denominator)
    sign = ""
    if f.numerator > 0 and include_plus:
      sign = " + "
    if f.numerator < 0:
       sign = " - "
       f = -f
    if f.numerator == 1 and variable != "":
       top = f"{sign}{variable}"
    else:
       top = f"{sign}{f.numerator}{variable}"
    if f.denominator == 1:
       return top
    return f"{top} / {f.denominator}"

class PlaneEquation:
   def __init__(self, A, B, C, D):
      self.A = A
      self.B = B
      self.C = C
      self.D = D
   def __str__(self):
      ba = fraction_format(- self.B, self.A, "y")
      ca = fraction_format(- self.C, self.A, "z", include_plus=True)
      da = fraction_format(- self.D, self.A, include_plus=True)
      return f"x = {ba} {ca} {da}"


def find_plane_equation(p1, p2, p3):
    v1 = [p2[i] - p1[i] for i in range(3)]
    v2 = [p3[i] - p1[i] for i in range(3)]
    normal = cross_product(v1, v2)
    A, B, C = normal
    D = -dot_product(normal, p1)
    return PlaneEquation(A, B, C, D)

def solve_for_x(equation, y, z):
    if equation.A == 0:
        raise ValueError("A cannot be zero for this equation.")
    return (-equation.B*y - equation.C*z - equation.D) // equation.A  # Use integer division for integers and fractions

# To-do:
#   - put padic_measure and padic_distance into a file called padic.py
#   - padic_measure should check to see if q is fractional. If it is,
#     then it should call itself with the numerator and denominator and
#     subtract the latter from the former.
def padic_measure(prime, q):
    if q == 0:
        return 0.0
    if q % prime != 0:
        return 1.0
    return 1.0 + padic_measure(prime, q // prime)

def padic_distance(prime, r, s):
    q = r - s
    answer = prime ** (- padic_measure(prime, q))
    return answer
    
best_triple = None
score = None
best_equation = None

for i, p1 in enumerate(data):
    for j, p2 in enumerate(data):
        if j <= i:
            continue
        for k, p3 in enumerate(data):
            if k <= i or k <= j:
                continue
            equation = find_plane_equation(p1, p2, p3)
            # Now, we go through each point in our data set and
            # see what the residual is.
            sum_of_residuals = 0.0
            for p4 in data:
                p4_hat = solve_for_x(equation, p4[1], p4[2])
                residual = padic_distance(args.prime, p4[0], p4_hat)
                sum_of_residuals += residual
            if score is None or sum_of_residuals < score:
                score = sum_of_residuals
                best_triple = (p1,p2,p3)
                best_equation = equation
                print(f"{best_equation}  -> {score}")

intercept = solve_for_x(best_equation, 0, 0)
print(intercept)

coef1 = solve_for_x(best_equation, 1, 0) - intercept
print(coef1)

coef2 = solve_for_x(best_equation, 0, 1) - intercept
print(coef2)
