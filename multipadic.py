#!/usr/bin/env python3
from create_zorgette_catalogue import Tuple
from create_zorgette_catalogue import Union
from create_zorgette_catalogue import List
from typing import Any

import argparse
import json
import fractions
import sympy
import padic
import sys

parser = argparse.ArgumentParser()
parser.add_argument("--prime", type=int, default=409,
                    help="What prime was used with create_zorgette_catalogue.py")
parser.add_argument("--input-file", default="zorgette-catalog.json",
                    help="File generated by create_zorgette_catalogue.py. Should be a list of 3-element lists")
parser.add_argument("--show-improvements", action="store_true",
                    help="Show each new better plane as it is discovered")
parser.add_argument("--show-all-calculations", action="store_true",
                    help="Verbose output of all calculations")
parser.add_argument("--show-largest-coefficient", action="store_true",
                    help="Show which variable had the largest value")
parser.add_argument("--output", help="Where to create a LaTeX file with the equation results")
args = parser.parse_args()

data = json.load(open(args.input_file))

# Something funny about this... there's only one division. That
# doesn't seem right. Unless A is really big?
def cross_product(v1: List[int], v2: List[int]) -> List[int]:
    return (
        v1[1] * v2[2] - v1[2] * v2[1],
        v1[2] * v2[0] - v1[0] * v2[2],
        v1[0] * v2[1] - v1[1] * v2[0]
    )

def dot_product(v1: List[int], v2: List[int]) -> int:
    return sum(x * y for x, y in zip(v1, v2))


def place_valued(prime: int, prime_symbol: sympy.Symbol, number: Union[int, fractions.Fraction]) -> sympy.Expr:
    if type(number) == fractions.Fraction:
        return place_valued(prime, prime_symbol, number.numerator) / place_valued(prime, prime_symbol, number.denominator)

    if number == 0:
        return 0
    signum = 1
    if number < 0:
        signum = -1
        number = -number
    # number is now positive
    expression = 0
    power = 0
    while number > 0:
        remainder = number % prime
        expression += remainder * (prime_symbol ** power)
        power += 1
        number = number - remainder
        number = number // prime
    return signum * expression


class PlaneEquation:
    def __init__(self, A: Union[int, fractions.Fraction], B: Union[int, fractions.Fraction], C: Union[int, fractions.Fraction], D: Union[int, fractions.Fraction]) -> None:
        self.A = A
        self.B = B
        self.C = C
        self.D = D

    def __eq__(self, other: Any) -> bool:
        if not isinstance(other, PlaneEquation):
            # don't attempt to compare against unrelated types
            return NotImplemented

        return self.fractional_expression_string() == other.fractional_expression_string()

    def __hash__(self) -> int:
        #return hash((self.A, self.B, self.C, self.D))
        return hash(self.fractional_expression_string())
    
    def predict(self, y: Union[int, fractions.Fraction], z: Union[int, fractions.Fraction]) -> fractions.Fraction:
        if self.A == 0:
            raise ValueError("A cannot be zero for this equation.")
        return fractions.Fraction(-self.B*y - self.C*z - self.D,self.A)

    def fractional_expression(self) -> Tuple[sympy.Expr, sympy.Expr]:
        x, y, z = sympy.symbols('x y z')
        self.fractional_lhs_expression = x
        self.fractional_rhs_expression = (
            - fractions.Fraction(self.B,self.A) * y
            - fractions.Fraction(self.C,self.A) * z
            - fractions.Fraction(self.D,self.A)
        )
        return (self.fractional_lhs_expression, self.fractional_rhs_expression)

    def fractional_expression_string(self):
        l,r = self.fractional_expression()
        return str(l) + " = " + str(r)

    def fractional_expression_latex(self):
        l,r = self.fractional_expression()
        return str(l) + " = " + str(r)    

    def integer_expression(self) -> Tuple[sympy.Expr, sympy.Expr]:
        x, y, z = sympy.symbols('x y z')
        self.integral_lhs_expression = self.A * x
        self.integral_rhs_expression = - self.B * y - self.C * z - self.D
        return (self.integral_lhs_expression, self.integral_rhs_expression)

    def integer_expression_string(self):
        l,r = self.integer_expression()
        return str(l) + " = " + str(r)

    def integer_expression_latex(self):
        l,r = self.integer_expression()
        return sympy.latex(l) + " = " + sympy.latex(r)

    def place_valued_integer_expression(self, prime: int) -> Tuple[sympy.Expr, sympy.Expr]:
        prime_symbol = sympy.symbols('p')
        a = place_valued(prime, prime_symbol, self.A)
        b = place_valued(prime, prime_symbol, self.B)
        c = place_valued(prime, prime_symbol, self.C)
        d = place_valued(prime, prime_symbol, self.D)
        x, y, z = sympy.symbols('x y z')
        l = x
        r = (
            - sympy.cancel(b * y / a)
            - sympy.cancel(c * z / a)
            - sympy.cancel(d / a)
        )
        return (l,r)

    def place_valued_integer_expression_string(self, prime):
        l,r = self.place_valued_integer_expression(prime)
        return f"{l} = {r}"

    def place_valued_fractional_expression(self, prime: int) -> Tuple[sympy.Expr, sympy.Expr, sympy.Expr, sympy.Expr]:
        prime_symbol = sympy.symbols('p')
        a = place_valued(prime, prime_symbol, self.A)
        b = place_valued(prime, prime_symbol, self.B)
        c = place_valued(prime, prime_symbol, self.C)
        d = place_valued(prime, prime_symbol, self.D)
        x, y, z = sympy.symbols('x y z')
        return (a * x, -b * y, -c * z, -d)

    def place_valued_fractional_expression_string(self, prime):
        t1,t2,t3,t4 = self.place_valued_fractional_expression(prime)
        l = t1
        r = t2 + t3 + t4
        return f"{l} = {r}"

    def line_broken_place_valued_fractional_expression_string(self, prime):
        t1,t2,t3,t4 = self.place_valued_fractional_expression(prime)
        return f"{t1} =\n {t2} +\n {t3} +\n {t4}"


    def place_valued_fractional_expression_string(self, prime):
        l,r = self.place_valued_fractional_expression(prime)
        return f"{l} = {r}"    


    
    def __str__(self):
        return self.integer_expression_string()

    def __repr__(self):
        return f"{self.fractional_expression_string()} :: {hash(self)} :: {self.A}, {self.B}, {self.C}, {self.D}"

def find_plane_equation(p1: List[int], p2: List[int], p3: List[int]) -> PlaneEquation:
    v1 = [p2[i] - p1[i] for i in range(3)]
    v2 = [p3[i] - p1[i] for i in range(3)]
    normal = cross_product(v1, v2)
    A, B, C = normal
    D = -dot_product(normal, p1)
    return PlaneEquation(A, B, C, D)


def find_best_hyperplane_by_brute_force(data: List[List[Union[int, fractions.Fraction]]], prime: int, show_each_improvement: bool = False, show_all_calcs: bool = False) -> PlaneEquation:
    if show_all_calcs:
        prime_symbol = sympy.symbols('p')
        #prime_symbol = sympy.symbols(str(prime))        
    score = None
    best_equation = None
    equations_already_seen = set()
    for i, p1 in enumerate(data):
        for j, p2 in enumerate(data):
            if j <= i:
                continue
            for k, p3 in enumerate(data):
                if k <= i or k <= j:
                    continue
                equation = find_plane_equation(p1, p2, p3)
                if equation in equations_already_seen:
                    if show_all_calcs:
                        sys.stderr.write(f"Skipping {equation}\n which has been seen before. It passes through:\n   {p1}\n   {p2}\n   {p3}\n\n")
                    continue
                equations_already_seen.update([equation])
                # Now, we go through each point in our data set and
                # see what the residual is.
                if show_all_calcs:
                    all_calc_output = [f"Testing  {equation}\n which passes through:\n   {p1}\n   {p2}\n   {p3}"]
                sum_of_residuals = 0.0
                for p4 in data:
                    p4_hat = equation.predict(p4[1], p4[2])
                    residual = padic.distance(prime, p4[0], p4_hat)
                    sum_of_residuals += residual
                    if show_all_calcs:
                        all_calc_output.append(f"  Predicted x={p4_hat} for y={p4[1]}, z={p4[2]}\n  Correct answer is {p4[0]}\n  Difference={p4_hat-p4[0]}\n  Place valued={place_valued(prime, prime_symbol, p4_hat-p4[0])}\n  \n  Measure = {padic.measure(prime, p4_hat-p4[0])}\n  Residual = {residual}")
                        
                if show_all_calcs:
                    all_calc_output.append(f" Sum = {sum_of_residuals}\n")
                    sys.stderr.write("\n\n".join(all_calc_output) + "\n\n\n")
                if score is None or sum_of_residuals < score:
                    score = sum_of_residuals
                    best_equation = equation
                    if show_each_improvement:
                        sys.stderr.write(f"{best_equation}  -> {score}\n")
    return best_equation

best_equation = find_best_hyperplane_by_brute_force(data, args.prime,
                                                    args.show_improvements,
                                                    args.show_all_calculations)

if args.output:
    f = open(args.output, 'w')
    f.write(r'\newcommand{\zorgetteints}[0]{')
    f.write(best_equation.fractional_expression_latex())
    f.write('}\n')
    f.close()
    
#print()
#print(best_equation.integer_expression_string())
#print(best_equation.line_broken_place_valued_fractional_expression_string(args.prime))
if args.show_largest_coefficient:
    if abs(best_equation.B) > abs(best_equation.C):
        print("y co-efficient is larger than z co-efficient")
    elif abs(best_equation.B) < abs(best_equation.C):
        print("z co-efficient is larger than y co-efficient")
    else:
        print("z co-efficient is equal to y co-efficient")
